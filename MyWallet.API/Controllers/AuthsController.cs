using Azure.Core;
using Microsoft.AspNetCore.Authentication;
using Microsoft.AspNetCore.Authentication.Google;
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Identity;
using Microsoft.AspNetCore.Mvc;
using MyWallet.Application.Contracts.IServices;
using MyWallet.Application.Contracts.ISubServices;
using MyWallet.Application.DTOs.Response;
using MyWallet.Application.DTOs.Response.Base;
using MyWallet.Domain.Constants;
using Pipelines.Sockets.Unofficial.Buffers;
using System.Configuration;

namespace MyWallet.API.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    public class AuthsController : ControllerBase
    {
        private readonly IAuthService _authService;
        private readonly IGoogleService _googleService;
        public AuthsController(IAuthService authService, IGoogleService googleService)
        {
            _authService = authService;
            _googleService = googleService;
        }

        [HttpGet("google-auth/signin")]
        [AllowAnonymous]
        public IActionResult SignIn([FromQuery] string origin)
        {
            if (string.IsNullOrWhiteSpace(origin))
                return BadRequest("Origin is required");

            try
            {
                Console.WriteLine($"\n=== SignIn Called ===");
                Console.WriteLine($"Origin: {origin}");
                Console.WriteLine($"Request Host: {Request.Host}");
                Console.WriteLine($"Request Scheme: {Request.Scheme}");

                // ✅ Clear cookies
                Response.Cookies.Delete("GoogleOAuthTemp");
                Response.Cookies.Delete(".AspNetCore.Cookies");

                // ✅ Get BaseUrl from config
                var baseUrl = BuildBaseUrl(Request);

                // ✅ Fallback if not configured
                if (string.IsNullOrEmpty(baseUrl))
                {
                    var scheme = Request.Scheme;
                    var host = Request.Host.Host;
                    var port = "";

                    if ((scheme == "https" && Request.Host.Port != 443) ||
                        (scheme == "http" && Request.Host.Port != 80))
                    {
                        port = $":{Request.Host.Port}";
                    }

                    baseUrl = $"{scheme}://{host}{port}";
                }

                var callbackPath = "/api/auths/google-auth/callback";
                var redirectUri = $"{baseUrl}{callbackPath}?origin={Uri.EscapeDataString(origin)}";

                Console.WriteLine($"BaseUrl: {baseUrl}");
                Console.WriteLine($"RedirectUri: {redirectUri}");
                Console.WriteLine("====================\n");

                var props = new AuthenticationProperties
                {
                    RedirectUri = redirectUri,
                    IsPersistent = false
                };

                return Challenge(props, GoogleDefaults.AuthenticationScheme);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error: {ex.Message}");
                return BadRequest(new
                {
                    error = ex.Message
                });
            }
        }

        [HttpGet("google-auth/callback")]
        [AllowAnonymous]
        public async Task<IActionResult> GoogleCallback([FromQuery] string origin)
        {
            if (string.IsNullOrWhiteSpace(origin))
                return BadRequest("Origin is required");

            try
            {
                // ✅ Check if authentication succeeded
                var result = await HttpContext.AuthenticateAsync("OAuthTemp");

                if (!result.Succeeded)
                {
                    Console.WriteLine($"Authentication failed: {result.Failure?.Message}");
                    return Redirect($"{origin}?error=auth_failed");
                }

                Console.WriteLine($"Authentication succeeded. Processing user...");

                // ✅ Now process the authenticated user
                var signInResult = await _authService.SignInGoogle(HttpContext);

                var response = new BaseResponseModel<SignInGoogleRes>(
                    SuccessCode.Success,
                    signInResult,
                    "Đăng nhập Google thành công!"
                );

                var html = _googleService.BuildSuccessHtml(response, origin);

                Console.WriteLine($"Returning success HTML");

                return Content(html, "text/html");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"SignInGoogle error: {ex.Message}\n{ex.StackTrace}");
                return Redirect($"{origin}?error={Uri.EscapeDataString(ex.Message)}");
            }
        }

        [HttpGet("me")]
        [Authorize]
        public async Task<IActionResult> Me()
        {
            GetUserRes result = await _authService.Me();
            return Ok(new BaseResponseModel<GetUserRes>(
                               code: SuccessCode.Success,
                               message: null,
                               data: result
                               ));
        }

        [HttpPost("signout")]
        [Authorize]
        public async Task<IActionResult> SignOut()
        {
            try
            {
                // ✅ Logout from OAuthTemp cookie
                await HttpContext.SignOutAsync("OAuthTemp");

                // ✅ Clear all cookies related to Google
                Response.Cookies.Delete("GoogleOAuthTemp");
                Response.Cookies.Delete(".AspNetCore.Cookies");

                return Ok(new BaseResponseModel<string>(code: SuccessCode.Success,
                                                        data: null,
                                                        message: "Đăng xuất thành công!"
                                                        ));
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Logout error: {ex.Message}");
                return BadRequest(new { error = ex.Message });
            }
        }

        private string BuildBaseUrl(HttpRequest request)
        {
            var scheme = request.Scheme;  // http hoặc https
            var host = request.Host.Host;  // domain (không có port)
            var port = "";

            // ✅ Chỉ thêm port nếu không phải standard port
            if ((scheme == "https" && request.Host.Port != 443) ||
                (scheme == "http" && request.Host.Port != 80))
            {
                port = $":{request.Host.Port}";
            }

            return $"{scheme}://{host}{port}";
        }
    }
}
